\chapter{Конструкторский раздел}
\label{cha:design}

В данном разделе проектируется алгоритм программы и описываются структуры данных, которые будут использоваться в программе.

\section{Общий алгоритм решения задачи}

\begin{enumerate}
\item Задать положение наблюдателя.

\item Задать объекты сцены.

\item Задать источники света и орбиту движения.

\item Для каждого кадра:

4.1 Обработка пользовательского ввода.

4.2 Обновить положение источника света, положение, материал объектов.

4.3 Для каждого пикселя вызвать под процедуру raytrace, вычислить цвет этого пикселя, сохранить в изображение.

4.4 Отобразить изображение.
\end{enumerate}


\section{Алгоритм трассировки лучей}


Поскольку рекурсивный алгоритм на gpu не поддерживает (glsl), я немного изменил алгоритм следующим образом

% $
% for each pixel on the viewing area
%     for each primitive in the world model
%         if ray-object intersection
%             select the frontmost intersection
%     calculate color
%     trace the relection and refraction rays
%     blend two color components
% $

\subsection*{Псевдокод}

\begin{verbatim}
Для каждого пикселя в области просмотра

    Пока глубина пути не превышает максимальную глубину
    и оставшаяся интенсивность больше 0.001

        Для каждого примитива
            если пересечение луча и объекта
                выбрать ближайший пересечение
        При пересечении с преломляющим материалом:
            превращается в преломленный луч или отраженный луч
            изменить показатель преломления среды
            изменить оставшуюся интенсивность света
        Иначе:
            применение модели освещения Фонга (с тестом теневых лучей)
            превращается в отраженный луч
            изменить оставшуюся интенсивность света
        Смешать два цветовых компонента
\end{verbatim}


% \subsection*{Пересечение трассирующего луча с треугольником}
\subsection*{Пересечение луча с сферой}

Параметрическая форма луча:
$P(t) = O + tD$

% Параметрические уравнения сферы:
Если точка P находится на сфере C радиуса r, то:
$(P-C)^2=r^2$

Если луч и сфера пересекаются, это уравнение должно иметь хотя бы одно решение:

$
(O + tD - C)^2 = r^2
$

$
t^2 \, D^2 + 2t \, D(O-C) + (O-C)^2 - r^2 = 0
$

После вычисления t получаем точку пересечения, мы можем вычислить нормаль к сфере в точке пересечения
$n = normalize(P-C)$


\subsection*{Пересечение луча с плоскостью}

$P_0$ - точка на плоскости, $N$ - вектор нормали к плоскости. Если точка $P$ лежит на плоскости, $P$ не совпадает с $P_0$, то:

$(P - P_0).N = 0$

Если луч пересекает плоскость в точке $P$:

$(O + tD - P_0).N = 0$

$t.D.N = (O-P_0).N$


\subsection*{Пересечение луча с треугольником}

Параметрическая форма луча: $P(t) = O + tD$

Параметрические уравнения плоскости: $Ax + By + Cz + E = 0$;\\
$N$ - вектор нормали

Решение точки пересечения луча и плоскости:

$t.D.N = -(N.O + E)$

Нужно еще выяснить, находится ли точка пересечения внутри треугольника.
Вычислить векторное произведение, определенного вершинами двух
ребер, и вектора, определенного вершиной и точкой первого ребра.
Вычислить скалярное произведение результирующего вектора и нормали многоугольника.
Знак полученного скалярного произведения определяет, находится ли точка
справа или слева от этого ребра. Повторять по каждому ребрам треугольника.
Нет необходимости проверять другие ребра, если один из них не прошел проверку.


\subsection*{Пересечение луча с кубом (aabb box)}

Выровненный по оси ограничивающий прямоугольник AABB может быть определен его минимальными и максимальными точками A и B.

AABB определяет набор плоскостей, перпендикулярных оси координат. Каждый компонент плоскости может быть определен следующим уравнением:

$
x = A_x, y = A_y, z = A_z
$

Точка, где луч пересекает одну из этих плоскостей:

$
O_x + t_x D_x = A_x
$

В векторной форме:

$t_A = (A - O) / D$ \quad $t_B = (B - O) / D$

Чтобы найти решение, которое действительно является пересечением с коробкой, требуется большее значение параметра t для пересечения в минимальной плоскости, требуется меньшее значение параметра t для пересечения в максимальной плоскости.


\subsection*{Отраженный луч}

Закон отражения: $\theta_i = \theta_r$

Отраженный луч $R$ рассчитывается следующим образом:\\

$
R = I - 2 (N.I)N
$

\subsection*{Преломленный луч}

Закон Снеллиуса: $n_1 sin(\theta_1) = n_2 sin(\theta_2)$

Преломленный луч $T$ рассчитывается следующим образом:\\

$n = \dfrac{n_1}{n_2}$\\

$c_1 = N.I$\qquad
$c_2 = \sqrt{1-n^2 sin^2(\theta)}$\\

$T = nI + (nc_1 - c_2)N$


% \subsection*{Распределение света световой точки}


% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.8\textwidth]{img/light_sphere.svg}
%     \caption{Алгоритм трассировки лучей}
%   \end{figure}


\section{Модель отражения Блинна - Фонга}

Применять с одним источником света:\\

$
\displaystyle I_p = k_ai_a + (k_d(L.N) + k_s(N.H)^\alpha) i
$\\

$
H = \dfrac{L + V}{||L + V||}
$
\\\\
где:\\
$k_a, k_s, k_d$ - коэффициент фонового, зеркального, диффузного освещения\\
$i_s, i_d$ - интенсивности зеркальной и диффузной составляющих источника света\\
$i_a$ - интенсивности окружающего света от всех источников света\\
$\alpha$ - которая является константой яркости материала\\
$L$ - вектор направления от точки на поверхности к источнику света\\
$N$ - нормаль в этой точке на поверхности\\
$R$ - направление, в котором идеально отраженный луч света будет направлен из этой точки на поверхности\\
$V$ - направление, указывающее на зрителя.


\section{Выбор типов и структур данных}

Ниже приведено описание структур данных, используемых в шейдере.

\begin{itemize}
    \item Ray: origin (vec3), direction (vec3)
    \item Sphere: center (vec3), radius (float), material
    \item Plane: normal (vec3), distance (float) (расстояние до центра сцены)
    \item AABB (параллельный осям ограничивающий параллелепипед): два точки bMin (vec3) и bMax (vec3)
    \item Triangle: v0, v1, v2 (vec3*3)
    \item Model: массив треугольников triangle[]
    \item Material: k\_ambient (vec3), k\_diffuse (vec3), k\_specular (vec3), shininess (float),
    k\_reflect (float), transparent (bool), ior (float)
    \item UBO: (Uniform Buffer Object) это структура данных используется для управления некоторыми атрибутами сцены.
    lightPos (vec3), ambient (float), cameraPos (vec3), aspectRatio (float), rotMat (mat4), material (Material), lightColor (vec3), raybounces (int);
\end{itemize}
